## 큐

- 큐 : 스택과 같이 데이터를 임시 저장하는 자료구조이다.  가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조이다.
- enqueue  :  큐에 데이터를 추가하는 작업
- dequeue : 큐에서 데이터를 꺼내는 작업
- front : 데이터를 꺼내는 쪽
- rear : 데이터를 넣는 쪽

### 배열로 큐 구현

1. 배열 이름을 que라 하면 que[0]~que[3]까지 int형 데이터가 저장된다.
2. 새로운 데이터를 enqueue 한다면 맨끝에 원소가 저장되어있는 que[3] 다음 원소인 que[4]에 새로운 데이터가 저장된다.
3. 기존에 넣어있던 데이터를 dequeue 한다면 가장 먼저 넣었던 que[0]의 값을 꺼내고 2번째 이후 모든 원소를 한칸씩 앞쪽으로 이동한다. 

### 링 버퍼로 큐 구현하기

- 링 버퍼 : 배열의 맨 끝의 원소 뒤에 맨 앞의 원소가 연결되는 자료구조이다.

   - dequeue할 때 배열 안의 원소를 옮기지 않는 큐이다.

- front : 맨 앞 원소의 인덱스
- rear : 맨 끝 원소 바로 뒤의 인덱스(다음 enqueue가 저장되는 위치)
- 링 버퍼의 경우 버퍼 내에 비어있는 공간에 enqueue를 하고 dequeue를 하였을 때 배열 안의 원소를 옮기지 않기에 front와 rear 값을 업데이트하는 것만으로 인큐와 디큐 수행가능
  - 모든 처리의 복잡도는 O(1)에 해당

### 고정 길이 큐 클래스 구현하기

- __init__ 함수의 변수

   - que : 큐의 배열로서 밀어 넣는 데이터를 저장하는 list형 배열

   - capacity : 큐의 최대 크기를 나타내는 int형 정수 - 배열 que의 원소 수와 일치

   - front, rear : 맨 앞의 원소, 맨 끝의 원소를 나타내는 인덱스 - 큐에 넣은 데이터 중에 가장 처음에 넣은 맨 앞 원소의 인덱스가 front, 가장 마지막에 넣은 맨 끝 원소의 바로 다음 인덱스가 rear이다.

rear은 다음에 인큐할 때 데이터를 저장하는 원소의 인덱스이다.

   - no : 큐에 쌓여 있는 데이터 개수를 나타내는 int형 정수이다. front와 rear값이 같을 경우 큐가 비어있는지 가득차 있는지 구별하기 위해 필요, 큐가 비어 있는 경우에는 no가 0이 되고, 가득차 있는 경우에는 capacity와 같은 값이 됨

- __len__( ) 함수 : 큐에 추가한 데이터 개수를 반환한다. no값은 그대로 반환

- is_empty( ) 함수 : 큐가 비어있는 지를 판단한다. 비어있다면 True, 그렇지 않다면 False를 반환

- is_full( ) 함수 : 큐가 가득 차 있어서 더 이상 데이터를 추가할 수 없는 상태인지 검사

      - 가득차 있다면 True를 그렇지 않으면 False를 반환

- enque( ) 함수 : 큐에 데이터를 인큐한다. 큐가 가득 차서 인큐할 수 없는 경우 예외 처리인 FixedQueue.Full을 내보낸다.

- deque( ) 함수 : 큐의 맨앞부터 데이터를 디큐하여 값을 반환한다. 큐가 비어있어 디큐할 수 없는 경우 예외 처리인 FixedQueue.Empty를 내보낸다.

- peek( ) 함수 : 맨 앞 데이터, 즉 다음 디큐에서 꺼낼 데이터를 들여다본다. que[front]의 값을 반환할 뿐 데이터를 꺼내지 않으므로 front, rear, no의 값은 변하지 않는다. 큐가 비어있을 때는 예외 처리인 FixedQueue.Empty를 내보낸다.

- find( ) 함수 : 큐의 배열에서 value와 같은 데이터가 포함되어있는 위치를 알아낸다. 맨 앞에서 맨 끝으로 선행 검색을 수행한다. 스캔의 경우 큐의 맨 앞 원소부터 시작한다.

- count( ) 함수 : 큐에 있는 데이터(value)의 개수를 구하여 반환한다.

- __ contains __ ( ) 함수 : 큐에 데이터가 들어 있는지를 판단한다. 들어있다면 True, 들어있지않다면 False를 반환한다. 내부의 count( ) 함수를 호출하여 구현한다.

- clear( ) 함수 : 현재 큐에 있는 모든 데이터를 삭제한다.

- dump( ) 함수 : 큐에 들어있는 모든 데이터를 맨 앞부터 맨 끝 쪽으로 순서대로 출력한다.